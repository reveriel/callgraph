# Call Graph Generator



## 设计

- 文件(module/file)
- 函数(function)
- 行(line)

多层次的调用图.

- File a, File b.
   文件的调用关系: 两个文件a,b 中 a中存在一行代码调用了 b 中定义的函数.
(问题: 定义和声明如何处理?)
-  File a, Func b.
  a 中存在一行代码调用了 b.
-  Func a, Func b.
  a 中存在一行代码调用了 b.
-  Line a, Func b.
   a 调用了 b.

交互式, 点击节点可以展开. File > Func > Line.


## 评价

在不同的编程风格, 设计模式下的效果.

## 难点

- indirect call, function pointer
- reflection, dynamic library
- C++ virtual function calls
- build system
- inline function, macro
- C++ template


## 相关工具

C project 函数调用图生成.

- [Egypt](http://www.gson.org/egypt/) (free software)
- [ncc](http://students.ceid.upatras.gr/~sxanth/ncc/)
- [KcacheGrind](https://kcachegrind.github.io/html/Home.html) (GPL)
- [Graphviz](http://www.graphviz.org/) (CPL)
- [CodeViz](https://github.com/petersenna/codeviz)(GPL)
- [doxygen](http://www.stack.nl/~dimitri/doxygen/)
- [Understand](https://scitools.com/features/)
- [tceetree](https://sourceforge.net/projects/tceetree/)
- [DMS Software Reengineering Toolkit](http://www.semanticdesigns.com/Products/DMS/DMSToolkit.html)
- [Astrée](https://www.absint.com/astree/index.htm)

ref :  [Tools to get a pictorial function call graph of code | stackoverflow](https://stackoverflow.com/questions/517589/tools-to-get-a-pictorial-function-call-graph-of-code)

### 相关工具简介.


####  [Egypt](http://www.gson.org/egypt/) (free software)

Egypt takes advantage of GCC's capability to dump an intermediate representation of the program being compiled into a file (a RTL file); this file is much easier to extract information from than a C source file. Egypt extracts information about function calls from the RTL file and massages it into the format used by Graphviz.

用 gcc 分析代码, graphviz 生成图.  100 行 perl 代码. 不支持 函数指针分析.
实际上做的就是从 RTL 文件里面找 `call` 和 `symbol_ref` 这两指令.

不支持跨文件. 因为 gcc 生成的 RTL 是单文件的. gcc 不会链接 RTL. 链接是 ld 的事(吧).

#### [ncc](http://students.ceid.upatras.gr/~sxanth/ncc/)

ncc is a compiler that produces program analysis information. ncc is a decent replacement of cflow and cscope able to analyse any program using the gcc compiler. The program also includes a graphical call-graph navigator and source browser which is extremely practical for hacking and comprehending large projects.

支持函数指针, see `doc/fptrs.c` and `doc/frag.c`. 支持多文件, 大项目.

The default output (at stdout) is that for every function defined in hello.c
the following things are reported :

    - function calls
    - pointer to function assigned values
    - use of global variables
    - use of members of structures

因为是一个 compiler, 自己实现的前端. 而且很久没人维护, 估计在实际使用是会有 C 的语法问题.


#### [KcacheGrind](https://kcachegrind.github.io/html/Home.html) (GPL)

The profiling tool **Callgrind** and the profile data visualization **KCachegrind**

Callgrind uses runtime instrumentation via the Valgrind framework for its cache simulation and call-graph generation. This way, even shared libraries and dynamically opened plugins can be profiled. The data files generated by Callgrind can be loaded into KCachegrind for browsing the performance results.

Callgrind 是 Valgrind 的一部分. Callgrind
定义了 Callgrind Format Specification. KCachegrind 将这种文件可视化.

[Callgrind Format Specification](http://valgrind.org/docs/manual/cl-format.html)



#### [Graphviz](http://www.graphviz.org/) (CPL)

note: 在图较大的时候, 使用  `neato` 比 `dot` 好. graphviz 提供了 C API `<gvc.h>`.

没有找到 call graph 功能.


#### [CodeViz](https://github.com/petersenna/codeviz)(GPL)


Perl 脚本, 大约几千行代码. C/C++ 支持.

`genfull` 脚本生成 project 完整的 call graph (dot 格式). 针对call graph 过大的
情况, 提供了 `gengraph` 脚本生成一些函数的生成子图.

有两种工作方式.
1. 依赖打 patch 的 gcc, 或者是使用 ncc (生成 `.nccout` 文件). patch 的 gcc 会对每个文件生成一个 `.cdepn` 文件, 包括call, line num, macro 等信息.  无法正确处理同名函数.
2. objdump 处理二进制文件.


#### [doxygen](http://www.stack.nl/~dimitri/doxygen/)

You can configure doxygen to extract the code structure from undocumented source files. This is very useful to quickly find your way in large source distributions. Doxygen can also visualize the relations between the various elements by means of include dependency graphs, inheritance diagrams, and collaboration diagrams, which are all generated automatically.


[Graphs and diagrams](http://www.stack.nl/~dimitri/doxygen/manual/diagrams.html)

- class hierarchy
- inheritance graph
- include dependency graph
- inverse include dependency graph
- A graph is drawn for each documented class and struct that shows the inheritance relations with base classes and the usage relations with other structs and classes
- a graphical **call graph** is drawn for each function showing the functions that the function directly or indirectly calls
-  a graphical **caller graph** is drawn for each function showing the functions that the function is directly or indirectly called by.

这个 call graph 是局部的, 以一个 function 为起点的图. 应该是因为整个项目的 call graph 可能会非常大. doxygen 使用 dot 生成图片, 太大的图片无法在浏览器中显示.

Note : The completeness (and correctness) of the call graph depends on the doxygen code parser which is not perfect.

#### [Understand](https://scitools.com/features/)




- [tceetree](https://sourceforge.net/projects/tceetree/)
- [DMS Software Reengineering Toolkit](http://www.semanticdesigns.com/Products/DMS/DMSToolkit.html)
- [Astrée](https://www.absint.com/astree/index.htm)



### doxygen.


